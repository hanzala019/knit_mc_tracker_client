<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Machine Status Duration Chart</title>
    <link href="styles/style.css" rel="stylesheet">
    <link href="styles/chart.css" rel="stylesheet">
    <style>
        .navbar{
            justify-content: space-evenly !important;
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
        }

        .settings-toggle {
            cursor: pointer;
            padding: 5px;
            margin-right: 20px;
            
        }

        .settings-panel {
            position: absolute;
            right: 10px;
            top: 40px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
            display: none;
            min-width: 250px;
        }

        .settings-panel.active {
            display: block;
        }

        .settings-section {
            margin-bottom: 15px;
        }

        .settings-section h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
        }
        .settings-actions {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #eee;
            text-align: right;
        }

        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            max-height: 200px;
            overflow-y: auto;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .reset-button {
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .reset-button:hover {
            background-color: #e0e0e0;
        }
        .shift-button {
            padding: 8px 16px;
            margin: 0 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #f0f0f0;
            cursor: pointer;
        }

        .shift-button.active {
            background-color: #007bff;
            color: white;
            border-color: #007bff;
        }

        .shift-button:hover:not(.active) {
            background-color: #e0e0e0;
        }
    </style>
</head>
<body>
    <script src="nav.js"></script>
    
    <nav class="navbar">
        <div class="logo">LOGO</div>
        <div class="nav-links">
            <a href="./mc_log.html" class="nav-link">Machine Logs</a>
            <a href="./chart.html" class="nav-link">Machine Chart</a>
            <a href="./report.html" class="nav-link">Report</a>
            <a href="./simulate.html" class="nav-link">Simulation</a>
        </div>
        <div class="user-section">
            <button class="logout-button">Logout</button>
        </div>
    </nav>

    <div class="shift-toggle" style="margin: 10px 0; text-align: center;">
        <button id="day-shift" class="shift-button">Day Shift (8 AM - 8 PM)</button>
        <button id="night-shift" class="shift-button">Night Shift (8 PM - 8 AM)</button>
    </div>

    <div class="container">
        <section class="chart-section">
            <div class="chart-header">
                <h1>Knitting Machine NPT Tracker</h1>
                <h1 id="currentDate" style="margin-right: 20px;"></h1>
            </div>
            <div class="chart-container">
                <div id="timeline-chart"></div>
            </div>     
        </section>
        <section class="chart-section">
            <div class="chart-header">
                <h1>Machine Duration Over Time</h1>
                <div class="settings-toggle">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="3"></circle>
                        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                    </svg>
                </div>
                <div class="settings-panel">
                    <div class="settings-section">
                        <h3>Select Reasons</h3>
                        <div class="checkbox-group" id="reason-checkboxes"></div>
                    </div>
                    <div class="settings-section">
                        <h3>Select Machines</h3>
                        <div class="checkbox-group" id="machine-checkboxes"></div>
                    </div>
                    <div class="settings-actions">
                        <button class="reset-button">Reset to Default</button>
                    </div>
                </div>
            </div>
            <div class="chart-container">
                <div id="duration-graph"></div>
            </div>
        </section>
        <section class="chart-section">
            <div class="chart-header">
                <h1>Machine Status Duration Analysis</h1>
            </div>
            <div class="chart-container">
                <div class="chart" id="reason-pie"></div>
                <div class="chart" id="machine-pie"></div>
                <div class="chart" id="reason-bar"></div>
                <div class="chart" id="machine-bar"></div>
            </div>
        </section>
    </div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
    let currentShift = determineCurrentShift();
    let selectedReasons = new Set(JSON.parse(localStorage.getItem('selectedReasons')) || []);
    let selectedMachines = new Set(JSON.parse(localStorage.getItem('selectedMachines')) || []);
    let chartData = null;
    let reasonData = null;
    let machineData = null;

    function runningTime(){
        document.getElementById("currentDate").textContent = "Running Time: " + formatSeconds(getCurrentTimeInMilliSeconds());
    }
    setInterval(runningTime, 1000);
    runningTime();

    function determineCurrentShift() {
        const now = new Date();
        const hour = now.getHours();
        return (hour >= 8 && hour < 20) ? 'day' : 'night';
    }

    function initializeSettings() {
        const settingsToggle = document.querySelector('.settings-toggle');
        const settingsPanel = document.querySelector('.settings-panel');

        settingsToggle.addEventListener('click', (e) => {
            e.stopPropagation();
            console.log('Gear icon clicked');
            if (chartData && reasonData && machineData) {
                settingsPanel.classList.toggle('active');
                console.log('Settings panel toggled, visible:', settingsPanel.classList.contains('active'));
            } else {
                console.log('Data not yet loaded, cannot show settings');
            }
        });

        const resetButton = document.querySelector('.reset-button');
        resetButton.addEventListener('click', () => {
            selectedReasons.clear();
            selectedMachines.clear();
            localStorage.removeItem('selectedReasons');
            localStorage.removeItem('selectedMachines');
            const checkboxes = document.querySelectorAll('.checkbox-item input[type="checkbox"]');
            checkboxes.forEach(checkbox => checkbox.checked = false);
            if (chartData && reasonData && machineData) {
                updateChart(chartData, reasonData, machineData);
            }
            settingsPanel.classList.remove('active');
        });

        document.addEventListener('click', (e) => {
            if (!settingsPanel.contains(e.target) && !settingsToggle.contains(e.target)) {
                settingsPanel.classList.remove('active');
            }
        });
    }

    function saveSelections() {
        localStorage.setItem('selectedReasons', JSON.stringify([...selectedReasons]));
        localStorage.setItem('selectedMachines', JSON.stringify([...selectedMachines]));
    }

    // Initialize from cache or fetch new data
document.addEventListener("DOMContentLoaded", () => {
    const links = document.querySelectorAll(".nav-link");
    const currentPage = window.location.pathname.split("/").pop().split(".")[0];
    links.forEach(link => {
        if (link.getAttribute("href").split("/").pop().split(".")[0] === currentPage) {
            link.classList.add("active");
        }
    });

    const dayShiftBtn = document.getElementById('day-shift');
    const nightShiftBtn = document.getElementById('night-shift');

    // Set initial active button based on current shift
    if (currentShift === 'day') {
        dayShiftBtn.classList.add('active');
        nightShiftBtn.classList.remove('active');
    } else {
        nightShiftBtn.classList.add('active');
        dayShiftBtn.classList.remove('active');
    }

    dayShiftBtn.addEventListener('click', () => {
        currentShift = 'day';
        dayShiftBtn.classList.add('active');
        nightShiftBtn.classList.remove('active');
        fetchAndUpdateCharts();
    });

    nightShiftBtn.addEventListener('click', () => {
        currentShift = 'night';
        nightShiftBtn.classList.add('active');
        dayShiftBtn.classList.remove('active');
        fetchAndUpdateCharts();
    });

    initializeSettings();
    
    // Try to load from cache first
    const cachedData = localStorage.getItem('chartDataCache');
    if (cachedData) {
        try {
            const { reasonData: cachedReasonData, machineData: cachedMachineData, timestamp } = JSON.parse(cachedData);
            const cacheTime = new Date(timestamp);
            const now = new Date();
            // If cache is less than 5 minutes old, use it
            if ((now - cacheTime) < 5 * 60 * 1000) {
                console.log('Using cached data');
                reasonData = cachedReasonData;
                machineData = cachedMachineData;
                // Still fetch to update the data but don't block UI
                fetchAndUpdateCharts();
                return;
            }
        } catch (e) {
            console.error('Error parsing cached data:', e);
        }
    }
    
    // No valid cache, fetch new data
    fetchAndUpdateCharts();
});

    function findStopReason(events, stopTime) {
    const stopTimeObj = new Date(stopTime instanceof Date ? stopTime : stopTime.replace('GMT', '').trim());
    
    // Look for button press events after this stop time
    const nextButtons = events.filter(event => 
        event.status === "Button Pressed" && 
        new Date(event.timestamp.replace('GMT', '').trim()) > stopTimeObj
    ).sort((a, b) => 
        new Date(a.timestamp.replace('GMT', '').trim()) - 
        new Date(b.timestamp.replace('GMT', '').trim())
    );
    
    // Get the first button press after the stop
    if (nextButtons.length > 0) {
        return nextButtons[0].reason || "N/A";
    }
    
    return "N/A";
}

function getLastStatusBeforeShift(events, shiftStart) {
    const sortedEvents = events
        .filter(event => event.status === "Machine On" || event.status === "Machine Off")
        .sort((a, b) => new Date(a.timestamp.replace('GMT', '').trim()) - 
                       new Date(b.timestamp.replace('GMT', '').trim()));
    
    const eventsBeforeShift = sortedEvents.filter(event => 
        new Date(event.timestamp.replace('GMT', '').trim()) < shiftStart
    );
    
    const lastEvent = eventsBeforeShift.length > 0 ? eventsBeforeShift[eventsBeforeShift.length - 1] : null;
    
    if (lastEvent) {
        const lastEventTime = new Date(lastEvent.timestamp.replace('GMT', '').trim());
        return {
            status: lastEvent.status,
            startTime: lastEventTime,
            reason: lastEvent.status === "Machine Off" ? findStopReason(events, lastEventTime) : "N/A"
        };
    } else {
        return {
            status: "Machine Off",
            startTime: shiftStart,
            reason: "No operation data"
        };
    }
}

    const CONFIG = {
        api: "https://organic-relative-wren.ngrok-free.app" || "https://knit-mc-tracker-server.onrender.com",
        refreshInterval: 60000,
        charts: {
            margin: { top: 20, right: 10, bottom: 20, left: 90 },
            width: 800,
            minHeight: 500,
            heightPerMachine: 25,
            barHeight: 10
        },
    };

    function formatSeconds(seconds) {
        const days = Math.floor(seconds / 86400);
        const hours = Math.floor((seconds % 86400) / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const secs = Math.floor(seconds % 60);

        let result = [];
        if (days > 0) result.push(`${days}d`);
        if (hours > 0) result.push(`${hours}h`);
        if (minutes > 0) result.push(`${minutes}min`);
        if (secs > 0) result.push(`${secs}sec`);
        return result.join(' ');
    }
    
    function getCurrentTimeInMilliSeconds(){
        const now = Date.now();
        const startOfToday = new Date();
        startOfToday.setHours(0, 0, 0, 0);
        return Math.floor((now - startOfToday.getTime()) / 1000);
    }
    
    function getContainerSize(containerId) {
        const container = document.getElementById(containerId);
        const rect = container.getBoundingClientRect();
        return {
            width: rect.width - 30,
            height: Math.min(rect.width - 30, 300)
        };
    }

    function formatDateTime(date) {
        return date.toLocaleString('en-US', {
            year: 'numeric',
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
        });
    }

    function createTooltip(content, event) {
        const tooltip = d3.select('body')
            .append('div')
            .attr('class', 'tooltip');

        tooltip.html(content)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 10) + 'px');
    }

    function createPieChart(data, containerId, title, colorScale) {
        const size = getContainerSize(containerId);
        const radius = Math.min(size.width, size.height) / 2.5;

        const svg = d3.select(`#${containerId}`)
            .append('svg')
            .attr('viewBox', `0 0 ${size.width} ${size.height + 30}`)
            .append('g')
            .attr('transform', `translate(${size.width/2},${size.height/2})`);

        d3.select(`#${containerId} svg`)
            .append('text')
            .attr('x', size.width/2)
            .attr('y', 20)
            .attr('text-anchor', 'middle')
            .style('font-size', '14px')
            .style('font-weight', 'bold')
            .text(title);

        const pie = d3.pie()
            .value(d => d.value)
            .sort(null);

        const arc = d3.arc()
            .innerRadius(0)
            .outerRadius(radius);

        const arcs = svg.selectAll('arc')
            .data(pie(data))
            .enter()
            .append('g');

        arcs.append('path')
            .attr('d', arc)
            .attr('fill', d => colorScale(d.data.reason || d.data.machine))
            .on('mouseover', function(event, d) {
                const percent = (d.value / d3.sum(data, d => d.value) * 100).toFixed(1);
                const totalTimeToday = getCurrentTimeInMilliSeconds();
                const percentageByTimePassed = ((d.value/totalTimeToday)* 100).toFixed(1);
                const content = `${d.data.reason ? (d.data.reason + " (" + d.data.count + ")") : d.data.machine}
                <br>${formatSeconds(d.value.toFixed(1))}s (${d.reason ? percent : percentageByTimePassed}%)`;
                createTooltip(content, event);
            })
            .on('mouseout', () => d3.selectAll('.tooltip').remove());

        const legend = d3.select(`#${containerId}`)
            .append('div')
            .attr('class', 'legend');

        data.forEach(d => {
            const legendItem = legend.append('div')
                .attr('class', 'legend-item');

            legendItem.append('div')
                .attr('class', 'legend-color')
                .style('background-color', colorScale(d.reason || d.machine));

            legendItem.append('span')
                .text(d.reason || d.machine);
        });
    }

    function createBarChart(data, containerId, title, colorScale) {
        const size = getContainerSize(containerId);
        const margin = { top: 40, right: 20, bottom: 100, left: 60 };
        const width = size.width - margin.left - margin.right;
        const height = size.height - margin.top - margin.bottom;

        const svg = d3.select(`#${containerId}`)
            .append('svg')
            .attr('viewBox', `0 0 ${size.width} ${size.height}`)
            .append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);

        svg.append('text')
            .attr('x', width/2)
            .attr('y', -20)
            .attr('text-anchor', 'middle')
            .style('font-size', '14px')
            .style('font-weight', 'bold')
            .text(title);

        const x = d3.scaleBand()
            .range([0, width])
            .domain(data.map(d => d.reason || d.machine))
            .padding(0.2);

        const y = d3.scaleLinear()
            .domain([0, d3.max(data, d => d.value)])
            .range([height, 0]);

        svg.append('g')
            .attr('transform', `translate(0,${height})`)
            .call(d3.axisBottom(x))
            .selectAll('text')
            .attr('transform', 'rotate(-45)')
            .style('text-anchor', 'end')
            .style('font-size', '10px');

        svg.append('g')
            .call(d3.axisLeft(y));

        svg.selectAll('bars')
            .data(data)
            .enter()
            .append('rect')
            .attr('x', d => x(d.reason || d.machine))
            .attr('y', d => y(d.value))
            .attr('width', x.bandwidth())
            .attr('height', d => height - y(d.value))
            .attr('fill', d => colorScale(d.reason || d.machine))
            .on('mouseover', function(event, d) {
                const percent = (d.value / d3.sum(data, d => d.value) * 100).toFixed(1);
                const now = Date.now();
                const startOfToday = new Date();
                startOfToday.setHours(0, 0, 0, 0);
                const totalTimeToday = Math.floor((now - startOfToday.getTime()) / 1000);
                const percentageByTimePassed = ((d.value/totalTimeToday)* 100).toFixed(1);
                const content = `
                ${d.reason || d.machine}
                <br>${formatSeconds(d.value.toFixed(1))}s (${d.reason ? percent : percentageByTimePassed}%)
                ${d.reason ? ("<br>Count: " + d.count) : ""}
                `;
                createTooltip(content, event);
            })
            .on('mouseout', () => d3.selectAll('.tooltip').remove());
    }

    function determineCurrentShift() {
    const now = new Date();
    const hour = now.getHours();
    return (hour >= 8 && hour < 20) ? 'day' : 'night';
}

function processFetchedData(data) {
    const processedData = [];
    const currentTime = new Date();
    
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const yesterday = new Date(today);
    yesterday.setDate(today.getDate() - 1);
    
    let shiftStart, shiftEnd;
    if (currentShift === 'day') {
        shiftStart = new Date(today);
        shiftStart.setHours(8, 0, 0, 0);
        shiftEnd = new Date(today);
        shiftEnd.setHours(20, 0, 0, 0);
    } else {
        const now = new Date();
        // For night shift, check if we're before or after midnight
        if (now.getHours() < 8) {
            // After midnight, before 8 AM
            shiftStart = new Date(yesterday);
            shiftStart.setHours(20, 0, 0, 0);
            shiftEnd = new Date(today);
            shiftEnd.setHours(8, 0, 0, 0);
        } else {
            // After 8 PM, before midnight
            shiftStart = new Date(today);
            shiftStart.setHours(20, 0, 0, 0);
            shiftEnd = new Date(today);
            shiftEnd.setDate(today.getDate() + 1);
            shiftEnd.setHours(8, 0, 0, 0);
        }
    }

    // Store all machine events regardless of shift for persistence
    if (!window.allMachineEvents) {
        window.allMachineEvents = {};
    }

    // Update or initialize the global events store
    data.machines.forEach(machineName => {
        const events = data.result[machineName] || [];
        if (!window.allMachineEvents[machineName]) {
            window.allMachineEvents[machineName] = events;
        } else {
            // Merge new events with existing ones, avoiding duplicates
            const existingTimestamps = new Set(window.allMachineEvents[machineName].map(e => e.timestamp));
            events.forEach(event => {
                if (!existingTimestamps.has(event.timestamp)) {
                    window.allMachineEvents[machineName].push(event);
                }
            });
            
            // Sort events by timestamp
            window.allMachineEvents[machineName].sort((a, b) => 
                new Date(a.timestamp.replace('GMT', '').trim()) - 
                new Date(b.timestamp.replace('GMT', '').trim())
            );
        }
    });

    data.machines.forEach(machineName => {
        const machineData = {
            machine: machineName,
            periods: []
        };
        
        // Use our persistent store instead of just current fetch
        const events = window.allMachineEvents[machineName] || [];
        const statusEvents = events.filter(event => 
            event.status === "Machine On" || event.status === "Machine Off"
        ).sort((a, b) => 
            new Date(a.timestamp.replace('GMT', '').trim()) - 
            new Date(b.timestamp.replace('GMT', '').trim())
        );
        
        const lastStatus = getLastStatusBeforeShift(events, shiftStart);
        
        if (statusEvents.length > 0) {
            const firstEvent = statusEvents.find(event => 
                new Date(event.timestamp.replace('GMT', '').trim()) >= shiftStart
            );
            
            if (!firstEvent || new Date(firstEvent.timestamp.replace('GMT', '').trim()) > shiftStart) {
                const endTime = firstEvent ? 
                    new Date(firstEvent.timestamp.replace('GMT', '').trim()) : 
                    (currentTime < shiftEnd ? currentTime : shiftEnd);
                
                if (endTime > shiftStart) {
                    machineData.periods.push({
                        status: lastStatus.status,
                        start: shiftStart,
                        actualStartTime: lastStatus.startTime,
                        end: endTime,
                        duration: (endTime - shiftStart) / 1000,
                        actualDuration: (endTime - lastStatus.startTime) / 1000,
                        reason: lastStatus.reason
                    });
                }
            }

            let startTime = null;
            let currentStatus = lastStatus.status;
            let reason = lastStatus.reason;
            let actualStartTimeForPeriod = lastStatus.startTime;
            
            statusEvents.forEach((event, index) => {
                const eventTime = new Date(event.timestamp.replace('GMT', '').trim());
                const eventActualStart = event.startTime ? 
                    new Date(event.startTime.replace('GMT', '').trim()) : eventTime;
                
                if (eventTime >= shiftStart && eventTime <= shiftEnd) {
                    if (startTime === null) {
                        startTime = eventTime;
                        actualStartTimeForPeriod = eventActualStart;
                        currentStatus = event.status;
                    } else {
                        const duration = (eventTime - startTime) / 1000;
                        const actualDuration = (eventTime - actualStartTimeForPeriod) / 1000;
                        
                        const period = {
                            status: currentStatus,
                            start: startTime,
                            actualStartTime: actualStartTimeForPeriod,
                            end: eventTime,
                            duration: duration,
                            actualDuration: actualDuration,
                        };

                        if (currentStatus === "Machine Off") {
                            // Look for button press event for reason
                            reason = findStopReason(events, startTime);
                        }
                        period.reason = reason;
                        machineData.periods.push(period);
                        startTime = eventTime;
                        actualStartTimeForPeriod = eventActualStart;
                        currentStatus = event.status;
                    }
                }
            });

            const lastEvent = statusEvents[statusEvents.length - 1];
            if (lastEvent && new Date(lastEvent.timestamp.replace('GMT', '').trim()) < shiftEnd) {
                const lastEventTime = new Date(lastEvent.timestamp.replace('GMT', '').trim());
                const endTime = currentTime < shiftEnd ? currentTime : shiftEnd;
                
                if (lastEventTime < endTime) {
                    const duration = (endTime - lastEventTime) / 1000;
                    const actualDuration = (endTime - actualStartTimeForPeriod) / 1000;
                    
                    machineData.periods.push({
                        status: lastEvent.status,
                        start: lastEventTime,
                        actualStartTime: actualStartTimeForPeriod,
                        end: endTime,
                        duration: duration,
                        actualDuration: actualDuration,
                        reason: lastEvent.status === "Machine Off" ? 
                            findStopReason(events, lastEventTime) : "Current Status"
                    });
                }
            }
        } else {
            const endTime = currentTime < shiftEnd ? currentTime : shiftEnd;
            const duration = (endTime - shiftStart) / 1000;
            machineData.periods.push({
                status: lastStatus.status,
                start: shiftStart,
                actualStartTime: lastStatus.startTime,
                end: endTime,
                duration: duration,
                actualDuration: (endTime - lastStatus.startTime) / 1000,
                reason: lastStatus.reason
            });
        }
        
        machineData.periods = machineData.periods.filter((item, index) => 
            machineData.periods.indexOf(item) === index);
        processedData.push(machineData);
    });

    return processedData;
}

    function createDurationGraph(data, machineColors) {
        const margin = { top: 40, right: 80, bottom: 60, left: 60 };
        const width = CONFIG.charts.width - margin.left - margin.right;
        const height = CONFIG.charts.minHeight - margin.top - margin.bottom;

        const svg = d3.select('#duration-graph')
            .append('svg')
            .attr('width', CONFIG.charts.width)
            .attr('height', CONFIG.charts.minHeight)
            .append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);

        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const yesterday = new Date(today);
        yesterday.setDate(today.getDate() - 1);
        
        let shiftStart, shiftEnd;
        if (currentShift === 'day') {
            shiftStart = new Date(today);
            shiftStart.setHours(8, 0, 0, 0);
            shiftEnd = new Date(today);
            shiftEnd.setHours(20, 0, 0, 0);
        } else {
            shiftStart = new Date(yesterday);
            shiftStart.setHours(20, 0, 0, 0);
            shiftEnd = new Date(today);
            shiftEnd.setHours(8, 0, 0, 0);
        }

        const x = d3.scaleTime()
            .domain([shiftStart, shiftEnd])
            .range([0, width]);

        const maxOffTime = d3.max(data, machine => {
            let totalOffTime = 0;
            machine.periods.forEach(period => {
                if (period.status === "Machine Off") {
                    totalOffTime += period.duration;
                }
            });
            return totalOffTime;
        }) || 43200;

        const roundedMax = Math.ceil(maxOffTime / 3600) * 3600;
        const y = d3.scaleLinear()
            .domain([0, roundedMax])
            .range([height, 0]);

        svg.append('g')
            .attr('transform', `translate(0,${height})`)
            .call(d3.axisBottom(x).ticks(6).tickFormat(d3.timeFormat("%H:%M")));

        const tickCount = 8;
        const tickStep = roundedMax / tickCount;
        const tickValues = Array.from({length: tickCount + 1}, (_, i) => i * tickStep);

        const formatTime = (seconds) => {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            return hours === 0 ? (minutes > 0 ? `${minutes}m` : "0") : 
                (minutes === 0 ? `${hours}h` : `${hours}h ${minutes}m`);
        };

        svg.append('g')
            .call(d3.axisLeft(y)
                .tickValues(tickValues)
                .tickFormat(d => formatTime(d)));

        const line = d3.line()
            .x(d => x(d.time))
            .y(d => y(d.duration));

        data.forEach(machine => {
            let cumulativeOffTime = 0;
            const lineData = [];
            
            machine.periods.forEach(period => {
                const startTime = period.start < shiftStart ? shiftStart : period.start;
                const endTime = period.end;
                
                lineData.push({
                    time: startTime,
                    duration: cumulativeOffTime
                });

                if (period.status === "Machine Off") {
                    cumulativeOffTime += period.duration;
                }

                lineData.push({
                    time: endTime,
                    duration: cumulativeOffTime
                });
            });

            svg.append('path')
                .datum(lineData)
                .attr('fill', 'none')
                .attr('stroke', machineColors(machine.machine))
                .attr('stroke-width', 2)
                .attr('d', line)
                .on('mouseover', function(event) {
                    createTooltip(machine.machine, event);
                })
                .on('mouseout', () => d3.selectAll('.tooltip').remove());
        });

        const legend = svg.append('g')
            .attr('class', 'legend')
            .attr('transform', `translate(${width + 20}, 0)`);

        data.forEach((d, i) => {
            const legendGroup = legend.append('g')
                .attr('transform', `translate(0, ${i * 20})`);

            legendGroup.append('rect')
                .attr('width', 10)
                .attr('height', 10)
                .attr('fill', machineColors(d.machine));

            legendGroup.append('text')
                .attr('x', 12)
                .attr('y', 8)
                .text(d.machine)
                .style('font-size', '9px');
        });
    }

    function updateChart(data, reasonData, machineData) {
        let filteredReasonData = reasonData;
        let filteredMachineData = machineData;
        let filteredData = data;

        if (selectedReasons.size > 0) {
            filteredReasonData = reasonData.filter(d => selectedReasons.has(d.reason));
        }

        if (selectedMachines.size > 0) {
            filteredMachineData = machineData.filter(d => selectedMachines.has(d.machine));
            filteredData = data.filter(d => selectedMachines.has(d.machine));
        }

        document.getElementById('timeline-chart').innerHTML = '';
        document.getElementById('duration-graph').innerHTML = '';
        document.getElementById('reason-pie').innerHTML = '';
        document.getElementById('machine-pie').innerHTML = '';
        document.getElementById('reason-bar').innerHTML = '';
        document.getElementById('machine-bar').innerHTML = '';

        d3.selectAll('.tooltip').remove();

        const reasonColors = d3.scaleOrdinal()
            .domain([
                "Maintenance",
                "Needle Breakage",
                "No Order / No Program",
                "No Yarn",
                "Power",
                "Program Change",
                "Roll Cutting",
                "Yarn Breakage",
                "N/A",
                "No operation data",
                "Machine On",
                "Future"
            ])
            .range([
                "#0040ff",
                "#FFA999",
                "#99cF99",
                "#FFdC99",
                "#11EEEE",
                "#cCFF",
                "#FFFFAA",
                "#FF22FF",
                "#ff1a1a",
                "#FFAACC",
                "#00e600",
                "#f0f0f0"
            ]);

        const machineColors = d3.scaleOrdinal()
            .domain(machineData.map(d => d.machine))
            .range(d3.schemeTableau10);

        const totalHeight = Math.max(CONFIG.charts.minHeight, filteredData.length * CONFIG.charts.heightPerMachine);
        const width = CONFIG.charts.width - CONFIG.charts.margin.left - CONFIG.charts.margin.right;
        const height = totalHeight - CONFIG.charts.margin.top - CONFIG.charts.margin.bottom;

        createDurationGraph(filteredData, machineColors);
        createPieChart(filteredReasonData, 'reason-pie', 'Reason wise NPT', reasonColors);
        createPieChart(filteredMachineData, 'machine-pie', 'Machine wise NPT', machineColors);
        createBarChart(filteredReasonData, 'reason-bar', 'Reason wise NPT', reasonColors);
        createBarChart(filteredMachineData, 'machine-bar', 'Machine wise NPT', machineColors);

        const svg = d3.select('#timeline-chart')
            .append('svg')
            .attr('width', CONFIG.charts.width)
            .attr('height', totalHeight)
            .append('g')
            .attr('transform', `translate(${CONFIG.charts.margin.left},${CONFIG.charts.margin.top})`);

        const y = d3.scaleBand()
            .domain(data.map(d => d.machine))
            .range([0, height])
            .padding(0.2);

        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const yesterday = new Date(today);
        yesterday.setDate(today.getDate() - 1);
        
        let shiftStart, shiftEnd;
        if (currentShift === 'day') {
            shiftStart = new Date(today);
            shiftStart.setHours(8, 0, 0, 0);
            shiftEnd = new Date(today);
            shiftEnd.setHours(20, 0, 0, 0);
        } else {
            shiftStart = new Date(yesterday);
            shiftStart.setHours(20, 0, 0, 0);
            shiftEnd = new Date(today);
            shiftEnd.setHours(8, 0, 0, 0);
        }

        const x = d3.scaleTime()
            .domain([shiftStart, shiftEnd])
            .range([0, width]);

        const machineGroups = svg.selectAll(".machine-group")
            .data(filteredData)
            .join("g")
            .attr("class", "machine-group")
            .attr("transform", d => `translate(0,${y(d.machine) + (y.bandwidth() - CONFIG.charts.barHeight) / 2})`);

        filteredData.forEach((machine, machineIndex) => {
            machineGroups
                .filter(d => d.machine === machine.machine)
                .selectAll("rect")
                .data(machine.periods)
                .join("rect")
                .attr("x", d => {
                    const barStart = d.start < shiftStart ? shiftStart : d.start;
                    return x(barStart);
                })
                .attr("width", d => {
                    const barStart = d.start < shiftStart ? shiftStart : d.start;
                    const barEnd = d.end;
                    return Math.max(0, x(barEnd) - x(barStart));
                })
                .attr("height", CONFIG.charts.barHeight)
                .attr("fill", d => {
                    if (d.status === "Machine On") return reasonColors("Machine On");
                    return reasonColors(d.reason || "N/A");
                })
                .attr("class", "bar")
                .on("mouseover", function(event, d) {
                    let tooltipContent = `
                        Status: ${d.status}<br/>
                        Start: ${d.start === d.actualStartTime ? formatDateTime(d.start) : formatDateTime(d.actualStartTime)}<br/>
                        End: ${formatDateTime(d.end)}<br/>
                        ${d.actualDuration != d.duration ? "Duration: " + formatSeconds(d.actualDuration.toFixed(1)) : "Duration: " + formatSeconds(d.duration.toFixed(1))}s 
                    `;
                    if (d.status === "Machine Off") {
                        tooltipContent += `<br/> Reason: ${d.reason}`;
                    }
                    createTooltip(tooltipContent, event);
                })
                .on("mouseout", function() {
                    d3.selectAll(".tooltip").remove();
                });
        });

        const xAxis = d3.axisBottom(x)
            .ticks(12)
            .tickFormat(d3.timeFormat("%H:%M"));

        const yAxis = d3.axisLeft(y);

        svg.append("g")
            .attr("class", "axis")
            .attr("transform", `translate(0,${height})`)
            .call(xAxis);

        svg.append("g")
            .attr("class", "axis")
            .call(yAxis)
            .selectAll(".tick line")
            .style("stroke", machineName => {
                const machineData = filteredData.find(d => d.machine === machineName);
                const lastPeriod = machineData?.periods[machineData.periods.length - 1];
                let color = 'black';
                if (lastPeriod?.status === "Machine On") {
                    color = '#22aa11';
                } else if (lastPeriod?.status === "Machine Off") {
                    const reasonColors = {
                        "Maintenance": "#0040ff",
                        "Needle Breakage": "#FFA999",
                        "No Order / No Program": "#99cF99",
                        "No Yarn": "#FFdC99",
                        "Power": "#11EEEE",
                        "Program Change": "#cCFF",
                        "Roll Cutting": "#FFFFAA",
                        "Yarn Breakage": "#FF22FF",
                        "N/A": "#ff1a1a",
                        "No operation data": "#FFAACC"
                    };
                    color = reasonColors[lastPeriod.reason] || '#ff1a1a';
                }
                return color;
            })
            .attr("stroke-width", 2)
            .attr("opacity", 0.7);

        svg.append("text")
            .attr("x", width / 2)
            .attr("y", height + 35)
            .attr("text-anchor", "middle")
            .text("Duration (seconds)");

        const legend = svg.append("g")
            .attr("class", "legend")
            .attr("transform", `translate(${width + 20}, 0)`);

        const legendItems = [
            { label: "Machine On", color: reasonColors("Machine On") },
            ...reasonData.map(d => ({ label: d.reason, color: reasonColors(d.reason) }))
        ];

        legendItems.forEach((item, i) => {
            const legendGroup = legend.append("g")
                .attr("transform", `translate(0, ${i * 20})`);

            legendGroup.append("rect")
                .attr("width", 15)
                .attr("height", 15)
                .attr("fill", item.color);

            legendGroup.append("text")
                .attr("x", 20)
                .attr("y", 12)
                .text(item.label)
                .style("font-size", "12px");
        });
    }

    function updateCheckboxes(data, reasonData, machineData) {
        const reasonCheckboxes = document.getElementById('reason-checkboxes');
        const machineCheckboxes = document.getElementById('machine-checkboxes');

        reasonCheckboxes.innerHTML = '';
        machineCheckboxes.innerHTML = '';

        reasonData.forEach(d => {
            const checkbox = document.createElement('div');
            checkbox.className = 'checkbox-item';
            checkbox.innerHTML = `
                <input type="checkbox" id="reason-${d.reason}" 
                       ${selectedReasons.has(d.reason) ? 'checked' : ''}>
                <label for="reason-${d.reason}">${d.reason}</label>
            `;
            checkbox.querySelector('input').addEventListener('change', (e) => {
                if (e.target.checked) selectedReasons.add(d.reason);
                else selectedReasons.delete(d.reason);
                saveSelections();
                updateChart(data, reasonData, machineData);
            });
            reasonCheckboxes.appendChild(checkbox);
        });

        machineData.forEach(d => {
            const checkbox = document.createElement('div');
            checkbox.className = 'checkbox-item';
            checkbox.innerHTML = `
                <input type="checkbox" id="machine-${d.machine}"
                       ${selectedMachines.has(d.machine) ? 'checked' : ''}>
                <label for="machine-${d.machine}">${d.machine}</label>
            `;
            checkbox.querySelector('input').addEventListener('change', (e) => {
                if (e.target.checked) selectedMachines.add(d.machine);
                else selectedMachines.delete(d.machine);
                saveSelections();
                updateChart(data, reasonData, machineData);
            });
            machineCheckboxes.appendChild(checkbox);
        });
    }

    function fetchAndUpdateCharts() {
    fetch(`${CONFIG.api}/api/mc-graph`)
        .then(response => response.json())
        .then(data => {
            let mc_no = localStorage.getItem("user");
            mc_no = JSON.parse(mc_no);
            data.machines = mc_no.machine === "All" ? data.machines : [mc_no.machine];
            chartData = processFetchedData(data);
            
            // Clear previous reason and machine data
            reasonData = [
                { reason: "Maintenance", value: 0, count: 0 },
                { reason: "Needle Breakage", value: 0, count: 0 },
                { reason: "No Order / No Program", value: 0, count: 0 },
                { reason: "No Yarn", value: 0, count: 0 },
                { reason: "Power", value: 0, count: 0 },
                { reason: "Program Change", value: 0, count: 0 },
                { reason: "Roll Cutting", value: 0, count: 0 },
                { reason: "Yarn Breakage", value: 0, count: 0 },
                { reason: "N/A", value: 0, count: 0 },
                { reason: "No operation data", value: 0, count: 0 }
            ];

            machineData = [];
            
            // Recalculate statistics from the processed data
            chartData.forEach(data => {
                machineData.push({"machine": data.machine, value: 0});
                let length = machineData.length - 1;
                data.periods.forEach(element => {
                    if(element.status === "Machine Off"){
                        machineData[length].value += element.duration;
                        for(let i = 0; i < reasonData.length; i++){
                            if(reasonData[i].reason === element.reason) {
                                reasonData[i].value += element.duration;
                                reasonData[i].count += 1;
                            }
                        }
                    }
                });
            });

            // Store the current data for persistence between page reloads
            localStorage.setItem('chartDataCache', JSON.stringify({
                reasonData: reasonData,
                machineData: machineData,
                timestamp: new Date().toISOString()
            }));

            console.log('Data fetched and processed:', {chartData, reasonData, machineData});
            updateCheckboxes(chartData, reasonData, machineData);
            updateChart(chartData, reasonData, machineData);
        })
        .catch(error => console.error('Error fetching data:', error));
}

    fetchAndUpdateCharts();
    setInterval(() => fetchAndUpdateCharts(), CONFIG.refreshInterval);
    </script>
</body>
</html>